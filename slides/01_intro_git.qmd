---
title: "Introduction to version control with Git"
subtitle: "Day 1: Concepts and a basic workflow"
author: "Selina Baldauf"
date: "Updated `r Sys.Date()`"
date-format: long
format: 
  revealjs:
    footer: "Version control with Git"
    highlight-style: printing
    mainfont: Cabinet Grotesk
    slide-number: true
    show-slide-number: all
    incremental: true
    self-contained: true
    code-line-numbers: false
    theme: slides.scss
    auto-stretch: false
    scrollable: true
editor: source
execute: 
  echo: false
  eval: true
from: markdown+emoji
---

## Welcome to the workshop

### Who am I?

- Scientific programmer theoretical ecology lab

. . .

### Who are you?

- Large range of topics and reserach interests
- [Different prior Git experience and expectations](https://docs.google.com/forms/d/1XBomnWIBaEXA0BorhIeVop6lfJ_02f7gDnkfPWJg-oE/edit#responses)

## Welcome to the workshop

- Git is a huge topic and it can become quite complex
- We will cover the most important steps for *individual* (today) and *collaborative* (tomorrow)
workflows

. . .

### At the end of this workshop you ...

... know the **basic concept** behind Git.

. . .

... can use Git for your **personal workflows**.


. . .

... can **collaborate** with your colleagues.

. . .

... can **publish your code** on Github.

. . .

... have an idea of more **advanced features**.

## Before we start

#### Organisation

- Today and tomorrow: :clock2: 2.30 - 4 p.m.
  - Theoretical input + practical exercises
  
- Next Monday: :clock2: 2.30 - 3.30 p.m.
  - Until then: Start working on a small Git project
  - Clarify questions and problems, talk about more advanced features, ...

- Material is all online

## Before we start

Did anyone have problems with the workshop preparation?

# Let's get started

## Why version control?

Two examples in which proper version control can be a life/time saver

. . .

![](img/day1/motivation_time.png){fig-align="center" width=70%}

. . .

![](img/day1/motivation_collab.png){fig-align="center" width=80%}

## Version control with Git

- **Complete** and **long-term** history of every file in your project

- **Open source and free** to use version control software

- Quasi **standard** for software development

- A whole universe of **other software and services** around it

## The basic idea of Git

- For projects with mainly text files (e.g. code, markdown files, ...)

- Basic idea: Take snapshots (**commits**) of your project over time

- A project version controlled with Git is a Git **repository** (**repo**)

. . .

![](img/day1/basic_idea.png)

## Version control with Git

Git is a **distributed version control system**

:::{.columns}

:::{.column width="50%"}

![](img/day1/distributed.png)

:::

:::{.column width="50%"}

- Idea: many *local* repositories synced via one *remote* repo
- Everyone has a complete copy of the repo

:::

:::

## How to use Git

After you [installed it](https://www.atlassian.com/de/git/tutorials/install-git) there are different ways to interact with the software.

## How to use Git - Terminal

Using Git from the terminal

![](images/2023_06_15_git/git-init.png)

. . . 

:::{.columns}

:::{.column width="50%"}

`r fontawesome::fa(name = "plus", fill = "green")` Most control<br>

`r fontawesome::fa(name = "plus", fill = "green")` A lot of help/answers online<br>

:::

:::{.column width="50%"}

`r fontawesome::fa(name = "minus", fill = "red")` You need to use the terminal :scream:<br>

:::

:::

## How to use Git - Integrated GUIs

A Git GUI is integrated in most (all?) IDEs, e.g. R Studio, VS Code

. . .

![](img/day1/rstudio_vscode_git.png){fig-align="center"}

. . .

:::{.columns}

:::{.column width="50%"}

`r fontawesome::fa(name = "plus", fill = "green")` Easy and intuitive <br>

`r fontawesome::fa(name = "plus", fill = "green")` Stay inside IDE<br>

:::

:::{.column width="50%"}

`r fontawesome::fa(name = "minus", fill = "red")` Different for every program <br>

:::

:::

## How to use Git - Standalone GUIs
  
Standalone Git GUI software, e.g. Github Desktop

![](img/day1/github_desktop.png){width=50% fig-align="center"}

. . .

:::{.columns}

:::{.column width="50%"}

`r fontawesome::fa(name = "plus", fill = "green")` Easy and intuitive <br>

`r fontawesome::fa(name = "plus", fill = "green")` Nice integration with Github <br>

:::

:::{.column width="50%"}

`r fontawesome::fa(name = "minus", fill = "red")` Switch programs to use Git <br>

:::

:::

## How to use Git

#### Which one to choose?

- Depends on experience and taste
- You can mix methods because they are all interfaces to the same Git

. . .

- We will use Github Desktop
  - I'll still mention the corresponding terminal commands for the terminology

. . .

:::{.callout-tip}

Have a look at the Website where you find How-To guides for all other methods as well.

:::


# The basic Git workflow

> `git init`, `git add`, `git commit`, `git push`

## Step 0: An empty project

:::{.columns}

:::{.column width="70%"}

**Concept:**

![](img/day1/0_init_concept.png)

:::

:::{.column width="30%"}

**Folder:**

![](img/day1/0_init_folder.png)

:::

:::

## Step 1: Initialize a git repository

- Adds a (hidden) `.git` folder to your project
  - You don't need to interact with this folder directly

. . .

:::{.columns}

:::{.column width=70%"}

**Conceptual:**

![](img/day1/1_init_concept.png)
:::

:::{.column width="30%"}

**Folder:**

![](img/day1/1_init_folder.png)

:::


:::

## Step 2: Modify files and stage changes

Git detects any changes in the working directory

. . .

:::{.columns}

:::{.column width="70%"}

**Concept:**

![](img/day1/2_modify_concept.png)

:::

:::{.column width="30%"}

**Folder:**

![](img/day1/2_modify_folder.png)

:::

:::


## Step 2: Modify files and stage changes

Stage file to be part of the next commit (snapshot)

- In the terminal use `git add`
- In GUIs just a check box

. . .

:::{.columns}

:::{.column width="70%"}

**Concept:**

![](img/day1/2_add_concept.png)

:::

:::{.column width="30%"}

**Folder:**

![](img/day1/2_add_folder.png)
:::

:::

## Step 3: Commit changes

- Commits are the snapshots of your project state
- Commit a bundle of changes from staging area to local repo
- Collect meaningful chunks of work in the staging area, then commit

. . .

:::{.columns}

:::{.column width="70%"}

**Concept:**

![](img/day1/3_commit_concept.png)

:::

:::{.column width="30%"}

**Folder:**

![](img/day1/2_add_folder.png)

:::

:::

## Step 3: Commit changes

- After a commit, the staging area is clear again
- Changes are now part of the project's Git history

. . .

:::{.columns}

:::{.column width="70%"}

**Concept:**

![](img/day1/3_afterCommit_concept.png)

:::

:::{.column width="30%"}

**Folder:**

![](img/day1/2_add_folder.png)

:::

:::

## The commit history

::: {layout="[[-1], [1], [-1]]" layout-valign="bottom"}

![](img/day1/commit_info_blank.png)

:::


## The commit history

::: {layout="[[-1], [1], [-1]]" layout-valign="bottom"}

![](img/day1/commit_info_arrows.png)

:::


## How to write good commit messages?

![[xkcd](https://xkcd.com/1296/) on commit messages](https://imgs.xkcd.com/comics/git_commit.png){fig-align="center" width=80%}

## How to write good commit messages?

See [here](https://cbea.ms/git-commit/) for more details but some general rules:

1. Limit summary line to 50 characters
2. Capitalize summary line
3. Do not end summary line with period
4. Use imperative mood in the subject line
5. Use the *Description* to explain **what** and **why**, not **how**

## How to write good commit messages?

:::{.columns}

:::{.column width="50%"}

:heavy_check_mark:

```
Limit model temperature range

I modified the temperature range the model can operate on to an upper limit of 40°C. This fixes the following problems:
- no more unrealistic results because temperature cannot exceed the meaningful range
- the program does not terminate with error code 123 anymore
```

:::

:::{.column width="50%"}

:x:

```
limited model temperature range.

Temperatures above 40°C are unrealistic.
```

:::

:::

## Step 4: Create and connect a remote repo

- Use remote repos (on a server) to *synchronize*, *share* and *collaborate*

- Remote repos can be *private* (you + collaborators) or
*public* (visible to anyone)

. . .


![](img/day1/4_remote_concept.png){fig-align="center" width=60%}

## Step 5: Share changes with the remote repo

- Push your local changes to the remote with `git push`

. . .

![](img/day1/4_push_concept.png){fig-align="center" width=60%}

## A word on remote repositories

- There are commercial and self-hosted options for your remote repositories
  - Commercial: Github, Gitlab, Bitbucket, ...
  - Self-hosted: Gitlab (maybe at your institution?)

- For the commercial options please be aware of your institutional guidelines
  - Servers are likely outside EU
  - Privacy rules might apply


## Summary of the basic steps

:::{.nonincremental}

- `git init`: Initialize a git repository
  - Adds a `.git` folder to your working directory
- `git add`: Add files to the staging area
  - This marks the files as being part of the next commit
- `git commit`: Take a snapshot of your current project version
  - Includes time stamp, commit message and information on the person who did the commit
- `git push`: Push new commits to the remote repository
  - Sync your local project version with the remote e.g. on Github

:::

# Go back in time with Git

> git log, git checkout, git revert

## The commit history

![](img/day1/commit_history.png)

- In the terminal use `git log`

. . .

![](img/day1/github_desktop_history.png)

## Checkout a previous commit

- Bring your work space back in time temporarily with `git checkout`

. . .

![](img/day1/commit_history_head.png)

. . .

![](img/day1/commit_history_checkout.png)

## Revert changes

- Use `git revert` to revert specific commits
- This does not delete the commit, it creates a new commit that undoes a
previous commit
  - It's a safe way to undo commited changes

. . .

![](img/day1/commit_history_after_revert.png)

# Other good things to know

> Ignore files, publish your projects

## Ignore files with `.gitignore`

- Use a `.gitignore` file to list files/folders that you don't want to track with git

. . .

::: {.nonincremental}

- Useful to ignore e.g.
  - Compiled code and build directories
  - Log files 
  - Hidden system files
  - Personal IDE config files
  - ...
  
:::
  
## Ignore files with `.gitignore`

- Create a file with the name `.gitignore` in working directory

- Add all files and directories you want to ignore to the `.gitignore` file

. . .

#### Example

```
*.html    # ignore all .html files
*.exe     # ignore all .exe files

debug.log # ignore the file debug.log

build/    # ignore all files in subdirectory build
```

See [here](https://www.atlassian.com/git/tutorials/saving-changes/gitignore) for more ignore patterns that you can use.

## Publish your repositories

Github/Gitlab are a good way to publish and share your work.

##### Advantages of publishing your code

- Others can build on your work
- You could get more citations
- You are forced to write nice, reproducible code
- Get feedback on your code

## Publish your repositories

You can increase the quality/complexity of your repo by

- Adding a README.md file
- Connecting the repo with Zenodo to get a DOI
- Create a Github pages Website alongside your repo
- Encourage people to write issues if they find problems
- ...

# Thanks for your attention

> Questions?
